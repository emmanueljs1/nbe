<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>NbE</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">
.Agda .Comment { color: #B22222 }
.Agda .Background {}
.Agda .Markup { color: #000000 }
.Agda .Keyword { color: #CD6600 }
.Agda .String { color: #B22222 }
.Agda .Number { color: #A020F0 }
.Agda .Symbol { color: #404040 }
.Agda .PrimitiveType { color: #0000CD }
.Agda .Pragma { color: black }
.Agda .Operator {}
.Agda .Hole { background: #B4EEB4 }

.Agda .Bound { color: black }
.Agda .Generalizable { color: black }
.Agda .InductiveConstructor { color: #008B00 }
.Agda .CoinductiveConstructor { color: #8B7500 }
.Agda .Datatype { color: #0000CD }
.Agda .Field { color: #EE1289 }
.Agda .Function { color: #0000CD }
.Agda .Module { color: #A020F0 }
.Agda .Postulate { color: #0000CD }
.Agda .Primitive { color: #0000CD }
.Agda .Record { color: #0000CD }

.Agda .DottedPattern {}
.Agda .UnsolvedMeta { color: black; background: yellow }
.Agda .UnsolvedConstraint { color: black; background: yellow }
.Agda .TerminationProblem { color: black; background: #FFA07A }
.Agda .IncompletePattern { color: black; background: #F5DEB3 }
.Agda .Error { color: red; text-decoration: underline }
.Agda .TypeChecks { color: black; background: #ADD8E6 }
.Agda .Deadcode { color: black; background: #808080 }
.Agda .ShadowingInTelescope { color: black; background: #808080 }

.Agda a { text-decoration: none }
.Agda a[href]:hover { background-color: #B4EEB4 }
.Agda [href].hover-highlight { background-color: #B4EEB4; }
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="normalization-by-evaulation">Normalization by Evaulation</h1>
<pre class="Agda"><a id="40" class="Keyword">import</a> <a id="47" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="85" class="Symbol">as</a> <a id="88" class="Module">Eq</a>
<a id="91" class="Keyword">open</a> <a id="96" class="Keyword">import</a> <a id="103" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="114" class="Keyword">using</a> <a id="120" class="Symbol">(</a><a id="121" href="Data.Empty.html#526" class="Datatype">⊥</a><a id="122" class="Symbol">)</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="146" class="Keyword">using</a> <a id="152" class="Symbol">(</a><a id="153" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="154" class="Symbol">;</a> <a id="156" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="158" class="Symbol">)</a>
<a id="160" class="Keyword">open</a> <a id="165" class="Keyword">import</a> <a id="172" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="181" class="Keyword">using</a> <a id="187" class="Symbol">(</a><a id="188" href="Data.Sum.Base.html#734" class="Datatype Operator">_⊎_</a><a id="191" class="Symbol">;</a> <a id="193" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a><a id="197" class="Symbol">;</a> <a id="199" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a><a id="203" class="Symbol">)</a>
<a id="205" class="Keyword">open</a> <a id="210" class="Keyword">import</a> <a id="217" href="Data.Product.html" class="Module">Data.Product</a> <a id="230" class="Keyword">using</a> <a id="236" class="Symbol">(</a><a id="237" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="240" class="Symbol">;</a> <a id="242" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="247" class="Symbol">;</a> <a id="249" href="Data.Product.html#1369" class="Function">∃</a><a id="250" class="Symbol">;</a> <a id="252" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="260" class="Symbol">)</a> <a id="262" class="Keyword">renaming</a> <a id="271" class="Symbol">(</a><a id="272" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a id="276" class="Symbol">to</a> <a id="279" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="284" class="Symbol">)</a>
<a id="286" class="Keyword">open</a> <a id="291" class="Keyword">import</a> <a id="298" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="315" class="Keyword">using</a> <a id="321" class="Symbol">(</a><a id="322" href="Relation.Nullary.html#1511" class="Record">Dec</a><a id="325" class="Symbol">;</a> <a id="327" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="330" class="Symbol">;</a> <a id="332" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="334" class="Symbol">)</a>
<a id="336" class="Keyword">open</a> <a id="341" href="Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="344" class="Keyword">using</a> <a id="350" class="Symbol">(</a><a id="351" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="354" class="Symbol">;</a> <a id="356" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="360" class="Symbol">)</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="SystemT.html" class="Module">SystemT</a>

<a id="384" class="Keyword">module</a> <a id="391" href="NbE.html" class="Module">NbE</a> <a id="395" class="Keyword">where</a>
</pre>
<p>Normalization by evaluation is the process of obtaining the normal
form of a term by evaluating it in a meta language (in our case,
Agda).</p>
<p>Evaluating terms in System T in our meta language will require
defining the interpretations of its types, contexts, and terms.</p>
We use the following record to represent interpretations of types and
contexts in System T, indicated by ⟦_⟧.
<pre class="Agda"><a id="792" class="Keyword">record</a> <a id="Interpretation"></a><a id="799" href="NbE.html#799" class="Record">Interpretation</a> <a id="814" class="Symbol">(</a><a id="815" href="NbE.html#815" class="Bound">D</a> <a id="817" class="Symbol">:</a> <a id="819" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="822" class="Symbol">)</a> <a id="824" class="Symbol">:</a> <a id="826" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="831" class="Keyword">where</a>
  <a id="839" class="Keyword">field</a>
    <a id="Interpretation.⟦_⟧"></a><a id="849" href="NbE.html#849" class="Field Operator">⟦_⟧</a> <a id="853" class="Symbol">:</a> <a id="855" href="NbE.html#815" class="Bound">D</a> <a id="857" class="Symbol">→</a> <a id="859" href="Agda.Primitive.html#326" class="Primitive">Set</a>

<a id="864" class="Keyword">open</a> <a id="869" href="NbE.html#799" class="Module">Interpretation</a> <a id="884" class="Symbol">{{...}}</a> <a id="892" class="Keyword">public</a>
</pre>
<p>The thesis first introduces a more traditional interpretation of
these, but these definitions will need to be updated in our final
implementation of the NbE algorithm.</p>
<p>For types, we can interpret naturals in System T as ℕ, and functions
in System T as Agda functions, defined inductively on their types.</p>
<pre><code>⟦ nat ⟧ = ℕ
⟦ S ⇒ T ⟧ = ⟦ S ⟧ → ⟦ T ⟧</code></pre>
<p>An empty context is interpreted as the unit type, and an extension to
a context is defined inductively, with the extension itself being the
interpretation of the type the context is extended with.</p>
<pre><code>⟦ ∅ ⟧ = ⊤
⟦ Γ , S ⟧ = ⟦ Γ ⟧ × ⟦ S ⟧</code></pre>
<p>From now on, we will use the metavariable ρ is used to represent
elements of ⟦ Γ ⟧ for a context Γ.</p>
<p>The interpretation of a variable expects the interpretation of a
context, and is essentially a lookup:</p>
<pre><code>⟦ Γ ∋ x:T ⟧ (ρ ∈ ⟦Γ⟧) ∈ ⟦ T ⟧
⟦ Γ , T ∋ x:T ⟧ (ρ , a) = a
⟦ Γ , y:S ∋ x:T ⟧ (ρ , _) = ⟦ Γ ∋ x:T ⟧ ρ</code></pre>
<p>The interpretation of a typed term expects the interpretation of a
context as well. It is more involed, so we only include the rule for
variables and abstractions:</p>
<pre><code>⟦ Γ ⊢ t : T ⟧ (ρ ∈ ⟦Γ⟧) = ⟦ T ⟧
⟦ Γ ⊢ x : T ⟧ ρ = ⟦ Γ ∋ x:T ⟧ ρ
⟦ Γ ⊢ λx . t : S ⇒ T ⟧ ρ  a  = ⟦ Γ , x:S ⊢ t : T ⟧ (ρ , a)</code></pre>
<p>As our final definition of interpretation will change, this is only a
rough sketch, but gives an idea of how we can evaluate terms in Agda.
For now, we only include the concrete interpretation of a context Γ
(generalized over any interpretation of types), as it will remain
unchanged.</p>
<pre class="Agda"><a id="2413" class="Keyword">instance</a>
    <a id="2426" class="Comment">-- We only include the concrete interpretation of a</a>
    <a id="2482" class="Comment">-- context Γ, generalized over any interpretation of</a>
    <a id="2539" class="Comment">-- types, to be used with the actual interpretation</a>
    <a id="2595" class="Comment">-- defined later</a>
    <a id="⟦Γ⟧"></a><a id="2616" href="NbE.html#2616" class="Function">⟦Γ⟧</a> <a id="2620" class="Symbol">:</a> <a id="2622" class="Symbol">{{</a><a id="2624" href="NbE.html#2624" class="Bound">_</a> <a id="2626" class="Symbol">:</a> <a id="2628" href="NbE.html#799" class="Record">Interpretation</a> <a id="2643" href="SystemT.html#561" class="Datatype">Type</a><a id="2647" class="Symbol">}}</a> <a id="2650" class="Symbol">→</a> <a id="2652" href="NbE.html#799" class="Record">Interpretation</a> <a id="2667" href="SystemT.html#1272" class="Datatype">Γ</a>
    <a id="2673" href="NbE.html#849" class="Field Operator">Interpretation.⟦</a> <a id="2690" href="NbE.html#2616" class="Function">⟦Γ⟧</a> <a id="2694" href="NbE.html#849" class="Field Operator">⟧</a> <a id="2696" href="SystemT.html#1288" class="InductiveConstructor">∅</a> <a id="2698" class="Symbol">=</a> <a id="2700" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
    <a id="2706" href="NbE.html#849" class="Field Operator">Interpretation.⟦</a> <a id="2723" href="NbE.html#2616" class="Function">⟦Γ⟧</a> <a id="2727" href="NbE.html#849" class="Field Operator">⟧</a> <a id="2729" class="Symbol">(</a><a id="2730" href="NbE.html#2730" class="Bound">Γ</a> <a id="2732" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="2734" href="NbE.html#2734" class="Bound">T</a><a id="2735" class="Symbol">)</a> <a id="2737" class="Symbol">=</a> <a id="2739" href="NbE.html#849" class="Field Operator">⟦</a> <a id="2741" href="NbE.html#2730" class="Bound">Γ</a> <a id="2743" href="NbE.html#849" class="Field Operator">⟧</a> <a id="2745" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="2747" href="NbE.html#849" class="Field Operator">⟦</a> <a id="2749" href="NbE.html#2734" class="Bound">T</a> <a id="2751" href="NbE.html#849" class="Field Operator">⟧</a>
</pre>
<p>To motivate our algorithm, first we recognize that normalization by
evaluation is, intuitively, the evaulation of an expression with
unknowns (e.g. variables) to another, possibly simplified, expression
with unknowns.</p>
<p>Because of this, we arrive at the first change to our interpretation
of terms. The interpretation of the base type nat is now terms of type
nat in their normal form – after all, a variable of type nat is
“blocked” and cannot be evaluated any further. In other words, we now
have:</p>
<pre><code>⟦ nat ⟧ = terms of type nat in their normal form</code></pre>
<p>From now on, normalized terms with unknowns will be referred to as
neutral terms (indicated by the metavariable 𝓊 for “unknown”), and
normalized terms in general will be referred to as normal terms
(indicated by the metavariable 𝓋 for “value”).</p>
<p>Additionally, while evaluation gives us the ability to normalize
terms, it also transforms them into our meta language. We want a way to
return to System T, which will be a function we will refer to as
reification. We will refer to its opposite, e.g. the transformation of a
term in System T into our meta language, as reflection.</p>
<p>The normal form of a typed term t in context Γ will be obtained by
using reflection and reification together. The following steps make up a
sketch of the algorithm:</p>
<ol type="1">
<li>reflect the variables of the context Γ (all of which are neutral
terms)</li>
<li>interpret the value of the term using the environment of reflected
variables</li>
<li>“reify” the interpreted value of the term (i.e. returning it to a
term in normal form)</li>
</ol>
<p>Before we can actually define the algorithm, we need to formally
introduce normal and neutral terms in Agda, which we define mutually.
The constructors for these represent the different types of normal
terms, and they are parametrized by the terms themselves.</p>
<pre class="Agda"><a id="4593" class="Comment">-- Neutral terms</a>
<a id="4610" class="Keyword">data</a> <a id="Ne"></a><a id="4615" href="NbE.html#4615" class="Datatype">Ne</a> <a id="4618" class="Symbol">(</a><a id="4619" href="NbE.html#4619" class="Bound">T</a> <a id="4621" class="Symbol">:</a> <a id="4623" href="SystemT.html#561" class="Datatype">Type</a><a id="4627" class="Symbol">)</a> <a id="4629" class="Symbol">(</a><a id="4630" href="NbE.html#4630" class="Bound">Γ</a> <a id="4632" class="Symbol">:</a> <a id="4634" href="SystemT.html#1272" class="Datatype">Γ</a><a id="4635" class="Symbol">)</a> <a id="4637" class="Symbol">:</a> <a id="4639" href="NbE.html#4630" class="Bound">Γ</a> <a id="4641" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="4643" href="NbE.html#4619" class="Bound">T</a> <a id="4645" class="Symbol">→</a> <a id="4647" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="4651" class="Comment">-- Normal Terms</a>
<a id="4667" class="Keyword">data</a> <a id="Nf"></a><a id="4672" href="NbE.html#4672" class="Datatype">Nf</a> <a id="4675" class="Symbol">:</a> <a id="4677" class="Symbol">(</a><a id="4678" href="NbE.html#4678" class="Bound">T</a> <a id="4680" class="Symbol">:</a> <a id="4682" href="SystemT.html#561" class="Datatype">Type</a><a id="4686" class="Symbol">)</a> <a id="4688" class="Symbol">→</a> <a id="4690" class="Symbol">(</a><a id="4691" href="NbE.html#4691" class="Bound">Γ</a> <a id="4693" class="Symbol">:</a> <a id="4695" href="SystemT.html#1272" class="Datatype">Γ</a><a id="4696" class="Symbol">)</a> <a id="4698" class="Symbol">→</a> <a id="4700" href="NbE.html#4691" class="Bound">Γ</a> <a id="4702" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="4704" href="NbE.html#4678" class="Bound">T</a> <a id="4706" class="Symbol">→</a> <a id="4708" href="Agda.Primitive.html#326" class="Primitive">Set</a>
</pre>
Neutral terms are normal terms in their blocked form. Variables are the
“base case” for blocked terms. Application on an unknown function to a
normal term is also blocked, as is recursion on an unknown natural.
blocked terms.
<pre class="Agda"><a id="4951" class="Keyword">data</a> <a id="4956" href="NbE.html#4615" class="Datatype">Ne</a> <a id="4959" href="NbE.html#4959" class="Bound">T</a> <a id="4961" href="NbE.html#4961" class="Bound">Γ</a> <a id="4963" class="Keyword">where</a>
  <a id="Ne.ne-var"></a><a id="4971" href="NbE.html#4971" class="InductiveConstructor">ne-var</a> <a id="4978" class="Symbol">:</a> <a id="4980" class="Symbol">(</a><a id="4981" href="NbE.html#4981" class="Bound">x</a> <a id="4983" class="Symbol">:</a> <a id="4985" href="NbE.html#4961" class="Bound">Γ</a> <a id="4987" href="SystemT.html#2683" class="Datatype Operator">∋</a> <a id="4989" href="NbE.html#4959" class="Bound">T</a><a id="4990" class="Symbol">)</a>
           <a id="5003" class="Comment">------------</a>
         <a id="5025" class="Symbol">→</a> <a id="5027" href="NbE.html#4615" class="Datatype">Ne</a> <a id="5030" href="NbE.html#4959" class="Bound">T</a> <a id="5032" href="NbE.html#4961" class="Bound">Γ</a> <a id="5034" class="Symbol">(</a><a id="5035" href="SystemT.html#3528" class="InductiveConstructor Operator">`</a> <a id="5037" href="NbE.html#4981" class="Bound">x</a><a id="5038" class="Symbol">)</a>

  <a id="Ne.ne-app"></a><a id="5043" href="NbE.html#5043" class="InductiveConstructor">ne-app</a> <a id="5050" class="Symbol">:</a> <a id="5052" class="Symbol">∀</a> <a id="5054" class="Symbol">{</a><a id="5055" href="NbE.html#5055" class="Bound">S</a> <a id="5057" class="Symbol">:</a> <a id="5059" href="SystemT.html#561" class="Datatype">Type</a><a id="5063" class="Symbol">}</a> <a id="5065" class="Symbol">{</a><a id="5066" href="NbE.html#5066" class="Bound">𝓊</a> <a id="5068" class="Symbol">:</a> <a id="5070" href="NbE.html#4961" class="Bound">Γ</a> <a id="5072" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5074" href="NbE.html#5055" class="Bound">S</a> <a id="5076" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5078" href="NbE.html#4959" class="Bound">T</a><a id="5079" class="Symbol">}</a> <a id="5081" class="Symbol">{</a><a id="5082" href="NbE.html#5082" class="Bound">𝓋</a> <a id="5084" class="Symbol">:</a> <a id="5086" href="NbE.html#4961" class="Bound">Γ</a> <a id="5088" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5090" href="NbE.html#5055" class="Bound">S</a><a id="5091" class="Symbol">}</a>
         <a id="5102" class="Symbol">→</a> <a id="5104" href="NbE.html#4615" class="Datatype">Ne</a> <a id="5107" class="Symbol">(</a><a id="5108" href="NbE.html#5055" class="Bound">S</a> <a id="5110" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5112" href="NbE.html#4959" class="Bound">T</a><a id="5113" class="Symbol">)</a> <a id="5115" href="NbE.html#4961" class="Bound">Γ</a> <a id="5117" href="NbE.html#5066" class="Bound">𝓊</a>
         <a id="5128" class="Symbol">→</a> <a id="5130" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5133" href="NbE.html#5055" class="Bound">S</a> <a id="5135" href="NbE.html#4961" class="Bound">Γ</a> <a id="5137" href="NbE.html#5082" class="Bound">𝓋</a>
           <a id="5150" class="Comment">--------------</a>
         <a id="5174" class="Symbol">→</a> <a id="5176" href="NbE.html#4615" class="Datatype">Ne</a> <a id="5179" href="NbE.html#4959" class="Bound">T</a> <a id="5181" href="NbE.html#4961" class="Bound">Γ</a> <a id="5183" class="Symbol">(</a><a id="5184" href="NbE.html#5066" class="Bound">𝓊</a> <a id="5186" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="5188" href="NbE.html#5082" class="Bound">𝓋</a><a id="5189" class="Symbol">)</a>

  <a id="Ne.ne-rec"></a><a id="5194" href="NbE.html#5194" class="InductiveConstructor">ne-rec</a> <a id="5201" class="Symbol">:</a> <a id="5203" class="Symbol">{</a><a id="5204" href="NbE.html#5204" class="Bound">𝓋z</a> <a id="5207" class="Symbol">:</a> <a id="5209" href="NbE.html#4961" class="Bound">Γ</a> <a id="5211" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5213" href="NbE.html#4959" class="Bound">T</a><a id="5214" class="Symbol">}</a> <a id="5216" class="Symbol">{</a><a id="5217" href="NbE.html#5217" class="Bound">𝓋s</a> <a id="5220" class="Symbol">:</a> <a id="5222" href="NbE.html#4961" class="Bound">Γ</a> <a id="5224" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5226" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="5230" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5232" href="NbE.html#4959" class="Bound">T</a> <a id="5234" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5236" href="NbE.html#4959" class="Bound">T</a><a id="5237" class="Symbol">}</a> <a id="5239" class="Symbol">{</a><a id="5240" href="NbE.html#5240" class="Bound">𝓊</a> <a id="5242" class="Symbol">:</a> <a id="5244" href="NbE.html#4961" class="Bound">Γ</a> <a id="5246" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5248" href="SystemT.html#580" class="InductiveConstructor">nat</a><a id="5251" class="Symbol">}</a>
         <a id="5262" class="Symbol">→</a> <a id="5264" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5267" href="NbE.html#4959" class="Bound">T</a> <a id="5269" href="NbE.html#4961" class="Bound">Γ</a> <a id="5271" href="NbE.html#5204" class="Bound">𝓋z</a>
         <a id="5283" class="Symbol">→</a> <a id="5285" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5288" class="Symbol">(</a><a id="5289" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="5293" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5295" href="NbE.html#4959" class="Bound">T</a> <a id="5297" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5299" href="NbE.html#4959" class="Bound">T</a><a id="5300" class="Symbol">)</a> <a id="5302" href="NbE.html#4961" class="Bound">Γ</a> <a id="5304" href="NbE.html#5217" class="Bound">𝓋s</a>
         <a id="5316" class="Symbol">→</a> <a id="5318" href="NbE.html#4615" class="Datatype">Ne</a> <a id="5321" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="5325" href="NbE.html#4961" class="Bound">Γ</a> <a id="5327" href="NbE.html#5240" class="Bound">𝓊</a>
           <a id="5340" class="Comment">--------------------------</a>
         <a id="5376" class="Symbol">→</a> <a id="5378" href="NbE.html#4615" class="Datatype">Ne</a> <a id="5381" href="NbE.html#4959" class="Bound">T</a> <a id="5383" href="NbE.html#4961" class="Bound">Γ</a> <a id="5385" class="Symbol">(</a><a id="5386" href="SystemT.html#3419" class="InductiveConstructor">rec</a> <a id="5390" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="5392" href="NbE.html#5204" class="Bound">𝓋z</a> <a id="5395" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="5397" href="NbE.html#5217" class="Bound">𝓋s</a> <a id="5400" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="5402" href="NbE.html#5240" class="Bound">𝓊</a><a id="5403" class="Symbol">)</a>
</pre>
Normal terms are terms in their normal form. <code>zero</code>, and
<code>suc</code> applied to a normal term are normalized naturals. An
abstraction whose body is normalized is itself normalized, as is any
neutral term.
<pre class="Agda"><a id="5617" class="Keyword">data</a> <a id="5622" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5625" class="Keyword">where</a>
  <a id="Nf.nf-zero"></a><a id="5633" href="NbE.html#5633" class="InductiveConstructor">nf-zero</a> <a id="5641" class="Symbol">:</a> <a id="5643" class="Symbol">∀</a> <a id="5645" class="Symbol">{</a><a id="5646" href="NbE.html#5646" class="Bound">Γ</a> <a id="5648" class="Symbol">:</a> <a id="5650" href="SystemT.html#1272" class="Datatype">Γ</a><a id="5651" class="Symbol">}</a> <a id="5653" class="Symbol">→</a> <a id="5655" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5658" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="5662" href="NbE.html#5646" class="Bound">Γ</a> <a id="5664" href="SystemT.html#3378" class="InductiveConstructor">zero</a>

  <a id="Nf.nf-suc"></a><a id="5672" href="NbE.html#5672" class="InductiveConstructor">nf-suc</a> <a id="5679" class="Symbol">:</a> <a id="5681" class="Symbol">∀</a> <a id="5683" class="Symbol">{</a><a id="5684" href="NbE.html#5684" class="Bound">Γ</a> <a id="5686" class="Symbol">:</a> <a id="5688" href="SystemT.html#1272" class="Datatype">Γ</a><a id="5689" class="Symbol">}</a> <a id="5691" class="Symbol">{</a><a id="5692" href="NbE.html#5692" class="Bound">𝓋</a> <a id="5694" class="Symbol">:</a> <a id="5696" href="NbE.html#5684" class="Bound">Γ</a> <a id="5698" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5700" href="SystemT.html#580" class="InductiveConstructor">nat</a><a id="5703" class="Symbol">}</a>
         <a id="5714" class="Symbol">→</a> <a id="5716" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5719" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="5723" href="NbE.html#5684" class="Bound">Γ</a> <a id="5725" href="NbE.html#5692" class="Bound">𝓋</a>
           <a id="5738" class="Comment">------------------</a>
         <a id="5766" class="Symbol">→</a> <a id="5768" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5771" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="5775" href="NbE.html#5684" class="Bound">Γ</a> <a id="5777" class="Symbol">(</a><a id="5778" href="SystemT.html#3396" class="InductiveConstructor">suc</a> <a id="5782" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="5784" href="NbE.html#5692" class="Bound">𝓋</a><a id="5785" class="Symbol">)</a>

  <a id="Nf.nf-abs"></a><a id="5790" href="NbE.html#5790" class="InductiveConstructor">nf-abs</a> <a id="5797" class="Symbol">:</a> <a id="5799" class="Symbol">∀</a> <a id="5801" class="Symbol">{</a><a id="5802" href="NbE.html#5802" class="Bound">S</a> <a id="5804" href="NbE.html#5804" class="Bound">T</a> <a id="5806" class="Symbol">:</a> <a id="5808" href="SystemT.html#561" class="Datatype">Type</a><a id="5812" class="Symbol">}</a> <a id="5814" class="Symbol">{</a><a id="5815" href="NbE.html#5815" class="Bound">Γ</a> <a id="5817" class="Symbol">:</a> <a id="5819" href="SystemT.html#1272" class="Datatype">Γ</a><a id="5820" class="Symbol">}</a> <a id="5822" class="Symbol">{</a><a id="5823" href="NbE.html#5823" class="Bound">𝓋</a> <a id="5825" class="Symbol">:</a> <a id="5827" href="NbE.html#5815" class="Bound">Γ</a> <a id="5829" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="5831" href="NbE.html#5802" class="Bound">S</a> <a id="5833" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5835" href="NbE.html#5804" class="Bound">T</a><a id="5836" class="Symbol">}</a>
         <a id="5847" class="Symbol">→</a> <a id="5849" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5852" href="NbE.html#5804" class="Bound">T</a> <a id="5854" class="Symbol">(</a><a id="5855" href="NbE.html#5815" class="Bound">Γ</a> <a id="5857" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="5859" href="NbE.html#5802" class="Bound">S</a><a id="5860" class="Symbol">)</a> <a id="5862" href="NbE.html#5823" class="Bound">𝓋</a>
           <a id="5875" class="Comment">------------------</a>
         <a id="5903" class="Symbol">→</a> <a id="5905" href="NbE.html#4672" class="Datatype">Nf</a> <a id="5908" class="Symbol">(</a><a id="5909" href="NbE.html#5802" class="Bound">S</a> <a id="5911" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="5913" href="NbE.html#5804" class="Bound">T</a><a id="5914" class="Symbol">)</a> <a id="5916" href="NbE.html#5815" class="Bound">Γ</a> <a id="5918" class="Symbol">(</a><a id="5919" href="SystemT.html#3588" class="InductiveConstructor Operator">ƛ</a> <a id="5921" href="NbE.html#5823" class="Bound">𝓋</a><a id="5922" class="Symbol">)</a>

  <a id="Nf.nf-neutral"></a><a id="5927" href="NbE.html#5927" class="InductiveConstructor">nf-neutral</a> <a id="5938" class="Symbol">:</a> <a id="5940" class="Symbol">∀</a> <a id="5942" class="Symbol">{</a><a id="5943" href="NbE.html#5943" class="Bound">T</a> <a id="5945" class="Symbol">:</a> <a id="5947" href="SystemT.html#561" class="Datatype">Type</a><a id="5951" class="Symbol">}</a> <a id="5953" class="Symbol">{</a><a id="5954" href="NbE.html#5954" class="Bound">Γ</a> <a id="5956" class="Symbol">:</a> <a id="5958" href="SystemT.html#1272" class="Datatype">Γ</a><a id="5959" class="Symbol">}</a> <a id="5961" class="Symbol">{</a><a id="5962" href="NbE.html#5962" class="Bound">𝓊</a> <a id="5964" class="Symbol">:</a> <a id="5966" href="NbE.html#5954" class="Bound">Γ</a> <a id="5968" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="5970" href="NbE.html#5943" class="Bound">T</a><a id="5971" class="Symbol">}</a>
             <a id="5986" class="Symbol">→</a> <a id="5988" href="NbE.html#4615" class="Datatype">Ne</a> <a id="5991" href="NbE.html#5943" class="Bound">T</a> <a id="5993" href="NbE.html#5954" class="Bound">Γ</a> <a id="5995" href="NbE.html#5962" class="Bound">𝓊</a>
               <a id="6012" class="Comment">--------</a>
             <a id="6034" class="Symbol">→</a> <a id="6036" href="NbE.html#4672" class="Datatype">Nf</a> <a id="6039" href="NbE.html#5943" class="Bound">T</a> <a id="6041" href="NbE.html#5954" class="Bound">Γ</a> <a id="6043" href="NbE.html#5962" class="Bound">𝓊</a>
</pre>
<p>With these defined, we can give a more formal (but still not final)
sketch of our algorithm:</p>
<pre><code>⟦ nat ⟧ = Nf nat

↑ᵀ ∈ Ne T → ⟦ T ⟧
↑ⁿᵃᵗ 𝓊 = 𝓊
↑ˢ⃗ᵗ 𝓊 (a ∈ ⟦ S ⟧) = ↑ᵀ (𝓊 𝓋) , 𝓋 = ↓ˢ a

↓ᵀ ∈ ⟦ T ⟧ → Nf T
↓ⁿᵃᵗ 𝓋 = 𝓋
↓ˢ⃗ᵗ f = λx. ↓ᵀ (f(a)) , where a = ↑ᵀ x and x is &quot;fresh&quot;

↑Γ ∈ ⟦ Γ ⟧
↑∅ = tt
↑Γ,x:S = ↑Γ , ↑ˢ x

nf(t) = ↓ᵀ (⟦ t ⟧ ↑Γ)</code></pre>
<p>The algorithm takes a term, evaluates it in an environment of
reflected variables, and then reifies it back to System T. However, this
sketch has an immediate issue to figure out – how to determine the
freshness condition for the variable x used when reifying at function
type.</p>
<p>As we are using de Brujin indices, this has a simple solution: just
extend the context. However, there is no context anywhere in our
definition of reification, so what context do we extend with the fresh
variable? This is actually intentional, because of an issue that is more
subtle: after we reflect the variable, it may later be reified in a
different context than it was created.</p>
<p>To address this, we introduce liftable terms. These are terms that
are generalized over contexts, and can be applied to any context Γ.</p>
<p>An effect of this is that it could be that the resulting term is not
well defined. In fact, it will be the case that liftable neutral terms
can only be applied to extensions of the context under which they were
created. Because of this, liftable neutrals will need to return a
placeholder value (tt) for some contexts.</p>
We append the up arrow ↑ for the liftable version of a System T
construct, and use 𝓋̂ and 𝓊̂ as the metavariables for liftable normal
terms and neutral terms respectively.
<pre class="Agda"><a id="7739" class="Comment">-- Liftable neutral term</a>
<a id="Ne↑"></a><a id="7764" href="NbE.html#7764" class="Function">Ne↑</a> <a id="7768" class="Symbol">:</a> <a id="7770" href="SystemT.html#561" class="Datatype">Type</a> <a id="7775" class="Symbol">→</a> <a id="7777" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="7781" href="NbE.html#7764" class="Function">Ne↑</a> <a id="7785" href="NbE.html#7785" class="Bound">T</a> <a id="7787" class="Symbol">=</a> <a id="7789" class="Symbol">∀</a> <a id="7791" class="Symbol">(</a><a id="7792" href="NbE.html#7792" class="Bound">Γ</a> <a id="7794" class="Symbol">:</a> <a id="7796" href="SystemT.html#1272" class="Datatype">Γ</a><a id="7797" class="Symbol">)</a> <a id="7799" class="Symbol">→</a> <a id="7801" href="Data.Product.html#1806" class="Function">∃[</a> <a id="7804" href="NbE.html#7804" class="Bound">t</a> <a id="7806" href="Data.Product.html#1806" class="Function">]</a> <a id="7808" href="NbE.html#4615" class="Datatype">Ne</a> <a id="7811" href="NbE.html#7785" class="Bound">T</a> <a id="7813" href="NbE.html#7792" class="Bound">Γ</a> <a id="7815" href="NbE.html#7804" class="Bound">t</a> <a id="7817" href="Data.Sum.Base.html#734" class="Datatype Operator">⊎</a> <a id="7819" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>

<a id="7822" class="Comment">-- Liftable normal term</a>
<a id="Nf↑"></a><a id="7846" href="NbE.html#7846" class="Function">Nf↑</a> <a id="7850" class="Symbol">:</a> <a id="7852" href="SystemT.html#561" class="Datatype">Type</a> <a id="7857" class="Symbol">→</a> <a id="7859" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="7863" href="NbE.html#7846" class="Function">Nf↑</a> <a id="7867" href="NbE.html#7867" class="Bound">T</a> <a id="7869" class="Symbol">=</a> <a id="7871" class="Symbol">∀</a> <a id="7873" class="Symbol">(</a><a id="7874" href="NbE.html#7874" class="Bound">Γ</a> <a id="7876" class="Symbol">:</a> <a id="7878" href="SystemT.html#1272" class="Datatype">Γ</a><a id="7879" class="Symbol">)</a> <a id="7881" class="Symbol">→</a> <a id="7883" href="Data.Product.html#1806" class="Function">∃[</a> <a id="7886" href="NbE.html#7886" class="Bound">t</a> <a id="7888" href="Data.Product.html#1806" class="Function">]</a> <a id="7890" href="NbE.html#4672" class="Datatype">Nf</a> <a id="7893" href="NbE.html#7867" class="Bound">T</a> <a id="7895" href="NbE.html#7874" class="Bound">Γ</a> <a id="7897" href="NbE.html#7886" class="Bound">t</a>
</pre>
Application of liftable terms is overloaded, i.e. (𝓊̂ 𝓋̂)(Γ) = 𝓊̂(Γ)𝓋̂(Γ)
<pre class="Agda"><a id="_·↑_"></a><a id="7986" href="NbE.html#7986" class="Function Operator">_·↑_</a> <a id="7991" class="Symbol">:</a> <a id="7993" class="Symbol">∀</a> <a id="7995" class="Symbol">{</a><a id="7996" href="NbE.html#7996" class="Bound">S</a> <a id="7998" href="NbE.html#7998" class="Bound">T</a> <a id="8000" class="Symbol">:</a> <a id="8002" href="SystemT.html#561" class="Datatype">Type</a><a id="8006" class="Symbol">}</a> <a id="8008" class="Symbol">→</a> <a id="8010" href="NbE.html#7764" class="Function">Ne↑</a> <a id="8014" class="Symbol">(</a><a id="8015" href="NbE.html#7996" class="Bound">S</a> <a id="8017" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="8019" href="NbE.html#7998" class="Bound">T</a><a id="8020" class="Symbol">)</a> <a id="8022" class="Symbol">→</a>  <a id="8025" href="NbE.html#7846" class="Function">Nf↑</a> <a id="8029" href="NbE.html#7996" class="Bound">S</a> <a id="8031" class="Symbol">→</a> <a id="8033" href="NbE.html#7764" class="Function">Ne↑</a> <a id="8037" href="NbE.html#7998" class="Bound">T</a>
<a id="8039" class="Symbol">(</a><a id="8040" href="NbE.html#8040" class="Bound">𝓊̂</a> <a id="8043" href="NbE.html#7986" class="Function Operator">·↑</a> <a id="8046" href="NbE.html#8046" class="Bound">𝓋̂</a><a id="8048" class="Symbol">)</a> <a id="8050" href="NbE.html#8050" class="Bound">Γ</a>    <a id="8055" class="Keyword">with</a>  <a id="8061" href="NbE.html#8040" class="Bound">𝓊̂</a> <a id="8064" href="NbE.html#8050" class="Bound">Γ</a> <a id="8066" class="Symbol">|</a>          <a id="8077" href="NbE.html#8046" class="Bound">𝓋̂</a> <a id="8080" href="NbE.html#8050" class="Bound">Γ</a>
<a id="8082" class="Symbol">...</a> <a id="8086" class="Symbol">|</a> <a id="8088" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="8093" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="8095" href="NbE.html#8095" class="Bound">𝓊</a> <a id="8097" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="8099" href="NbE.html#8099" class="Bound">pf-𝓊</a> <a id="8104" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="8106" class="Symbol">|</a> <a id="8108" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="8110" href="NbE.html#8110" class="Bound">𝓋</a> <a id="8112" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="8114" href="NbE.html#8114" class="Bound">pf-𝓋</a> <a id="8119" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="8121" class="Symbol">=</a>
      <a id="8129" class="Comment">-- Note that we need to provide proof</a>
      <a id="8173" class="Comment">-- that our resulting lifted term is</a>
      <a id="8216" class="Comment">-- a neutral term as well</a>
      <a id="8248" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="8253" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="8255" href="NbE.html#8095" class="Bound">𝓊</a> <a id="8257" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="8259" href="NbE.html#8110" class="Bound">𝓋</a> <a id="8261" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="8263" href="NbE.html#5043" class="InductiveConstructor">ne-app</a> <a id="8270" href="NbE.html#8099" class="Bound">pf-𝓊</a> <a id="8275" href="NbE.html#8114" class="Bound">pf-𝓋</a> <a id="8280" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
<a id="8282" class="Symbol">...</a> <a id="8286" class="Symbol">|</a> <a id="8288" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="8293" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>           <a id="8306" class="Symbol">|</a> <a id="8308" class="Symbol">_</a> <a id="8310" class="Symbol">=</a> <a id="8312" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="8317" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
</pre>
Since normalization by evaluation will need to be over liftable terms,
the concrete interpretation of the base type nat will in the end be
naturals with embedded liftable neutrals, which we can now finally
define in Agda, along with the interpretation of types.
<pre class="Agda"><a id="8595" class="Keyword">data</a> <a id="ℕ̂"></a><a id="8600" href="NbE.html#8600" class="Datatype">ℕ̂</a> <a id="8603" class="Symbol">:</a> <a id="8605" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="8609" class="Keyword">where</a>
  <a id="ℕ̂.zero"></a><a id="8617" href="NbE.html#8617" class="InductiveConstructor">zero</a> <a id="8622" class="Symbol">:</a> <a id="8624" href="NbE.html#8600" class="Datatype">ℕ̂</a>
  <a id="ℕ̂.suc"></a><a id="8629" href="NbE.html#8629" class="InductiveConstructor">suc</a> <a id="8633" class="Symbol">:</a> <a id="8635" href="NbE.html#8600" class="Datatype">ℕ̂</a> <a id="8638" class="Symbol">→</a> <a id="8640" href="NbE.html#8600" class="Datatype">ℕ̂</a>
  <a id="ℕ̂.ne"></a><a id="8645" href="NbE.html#8645" class="InductiveConstructor">ne</a> <a id="8648" class="Symbol">:</a> <a id="8650" href="NbE.html#7764" class="Function">Ne↑</a> <a id="8654" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="8658" class="Symbol">→</a> <a id="8660" href="NbE.html#8600" class="Datatype">ℕ̂</a>

<a id="8664" class="Keyword">instance</a>
  <a id="⟦Type⟧"></a><a id="8675" href="NbE.html#8675" class="Function">⟦Type⟧</a> <a id="8682" class="Symbol">:</a> <a id="8684" href="NbE.html#799" class="Record">Interpretation</a> <a id="8699" href="SystemT.html#561" class="Datatype">Type</a>
  <a id="8706" href="NbE.html#849" class="Field Operator">Interpretation.⟦</a> <a id="8723" href="NbE.html#8675" class="Function">⟦Type⟧</a> <a id="8730" href="NbE.html#849" class="Field Operator">⟧</a> <a id="8732" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="8736" class="Symbol">=</a> <a id="8738" href="NbE.html#8600" class="Datatype">ℕ̂</a>
  <a id="8743" href="NbE.html#849" class="Field Operator">Interpretation.⟦</a> <a id="8760" href="NbE.html#8675" class="Function">⟦Type⟧</a> <a id="8767" href="NbE.html#849" class="Field Operator">⟧</a> <a id="8769" class="Symbol">(</a><a id="8770" href="NbE.html#8770" class="Bound">S</a> <a id="8772" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="8774" href="NbE.html#8774" class="Bound">T</a><a id="8775" class="Symbol">)</a> <a id="8777" class="Symbol">=</a> <a id="8779" href="NbE.html#849" class="Field Operator">⟦</a> <a id="8781" href="NbE.html#8770" class="Bound">S</a> <a id="8783" href="NbE.html#849" class="Field Operator">⟧</a> <a id="8785" class="Symbol">→</a> <a id="8787" href="NbE.html#849" class="Field Operator">⟦</a> <a id="8789" href="NbE.html#8774" class="Bound">T</a> <a id="8791" href="NbE.html#849" class="Field Operator">⟧</a>
</pre>
<p>With this, we begin the most important part of normalization by
evaluation, the reflection and reification functions. These are mutually
recursive, and will be defined inductively on the type T</p>
<pre class="Agda"><a id="9001" class="Comment">-- Reflection of neutral terms of type T into</a>
<a id="9047" class="Comment">-- semantic objects in ⟦T⟧</a>
<a id="↑ᵀ"></a><a id="9074" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="9077" class="Symbol">:</a> <a id="9079" class="Symbol">{</a><a id="9080" href="NbE.html#9080" class="Bound">T</a> <a id="9082" class="Symbol">:</a> <a id="9084" href="SystemT.html#561" class="Datatype">Type</a><a id="9088" class="Symbol">}</a> <a id="9090" class="Symbol">→</a> <a id="9092" href="NbE.html#7764" class="Function">Ne↑</a> <a id="9096" href="NbE.html#9080" class="Bound">T</a> <a id="9098" class="Symbol">→</a> <a id="9100" href="NbE.html#849" class="Field Operator">⟦</a> <a id="9102" href="NbE.html#9080" class="Bound">T</a> <a id="9104" href="NbE.html#849" class="Field Operator">⟧</a>

<a id="9107" class="Comment">-- Reification of semantic objects in ⟦T⟧ into</a>
<a id="9154" class="Comment">-- normal terms of type T</a>
<a id="↓ᵀ"></a><a id="9180" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="9183" class="Symbol">:</a> <a id="9185" class="Symbol">{</a><a id="9186" href="NbE.html#9186" class="Bound">T</a> <a id="9188" class="Symbol">:</a> <a id="9190" href="SystemT.html#561" class="Datatype">Type</a><a id="9194" class="Symbol">}</a> <a id="9196" class="Symbol">→</a> <a id="9198" href="NbE.html#849" class="Field Operator">⟦</a> <a id="9200" href="NbE.html#9186" class="Bound">T</a> <a id="9202" href="NbE.html#849" class="Field Operator">⟧</a> <a id="9204" class="Symbol">→</a> <a id="9206" href="NbE.html#7846" class="Function">Nf↑</a> <a id="9210" href="NbE.html#9186" class="Bound">T</a>
</pre>
As was the case in the sketch of the algorithm, the reflection of a
liftable neutral of type nat into the metalanguage (i.e. into a term ℕ̂)
is just the liftable neutral itself, embedded with the ne constructor.
<pre class="Agda"><a id="9437" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="9440" class="Symbol">{</a><a id="9441" href="SystemT.html#580" class="InductiveConstructor">nat</a><a id="9444" class="Symbol">}</a> <a id="9446" href="NbE.html#9446" class="Bound">𝓊̂</a> <a id="9449" class="Symbol">=</a> <a id="9451" href="NbE.html#8645" class="InductiveConstructor">ne</a> <a id="9454" href="NbE.html#9446" class="Bound">𝓊̂</a>
</pre>
As for the reflection of neutral terms of type S ⇒ T into ⟦S⟧ → ⟦T⟧, we
reify a semantic object in ⟦S⟧ and then reflect the neutral term
resulting from the application of the reified object to the original
neutral term. Here, we use the liftable application operation we defined
earlier.
<pre class="Agda"><a id="9758" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="9761" class="Symbol">{</a><a id="9762" href="NbE.html#9762" class="Bound">S</a> <a id="9764" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="9766" href="NbE.html#9766" class="Bound">T</a><a id="9767" class="Symbol">}</a> <a id="9769" href="NbE.html#9769" class="Bound">𝓊̂</a> <a id="9772" href="NbE.html#9772" class="Bound">a</a> <a id="9774" class="Symbol">=</a> <a id="9776" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="9779" class="Symbol">(</a><a id="9780" href="NbE.html#9769" class="Bound">𝓊̂</a> <a id="9783" href="NbE.html#7986" class="Function Operator">·↑</a> <a id="9786" href="NbE.html#9796" class="Function">𝓋̂</a><a id="9788" class="Symbol">)</a> <a id="9790" class="Keyword">where</a> <a id="9796" href="NbE.html#9796" class="Function">𝓋̂</a> <a id="9799" class="Symbol">=</a> <a id="9801" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="9804" href="NbE.html#9772" class="Bound">a</a>
</pre>
For the reification of semantic objects of type ⟦nat⟧, which are our
naturals with embedded liftable neutrals (ℕ̂), we define the following
helper function.
<pre class="Agda"><a id="↓ℕ̂"></a><a id="9976" href="NbE.html#9976" class="Function">↓ℕ̂</a> <a id="9980" class="Symbol">:</a> <a id="9982" href="NbE.html#849" class="Field Operator">⟦</a> <a id="9984" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="9988" href="NbE.html#849" class="Field Operator">⟧</a> <a id="9990" class="Symbol">→</a> <a id="9992" href="NbE.html#7846" class="Function">Nf↑</a> <a id="9996" href="SystemT.html#580" class="InductiveConstructor">nat</a>
<a id="10000" href="NbE.html#9976" class="Function">↓ℕ̂</a> <a id="10004" href="NbE.html#8617" class="InductiveConstructor">zero</a> <a id="10009" class="Symbol">=</a> <a id="10011" class="Symbol">(λ</a> <a id="10014" href="NbE.html#10014" class="Bound">_</a> <a id="10016" class="Symbol">→</a> <a id="10018" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="10020" href="SystemT.html#3378" class="InductiveConstructor">zero</a> <a id="10025" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="10027" href="NbE.html#5633" class="InductiveConstructor">nf-zero</a> <a id="10035" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a><a id="10036" class="Symbol">)</a>
</pre>
For the successor case, we reify the successor into a liftable successor
function (suc↑) applied to the reification of the argument to the
successor function
<pre class="Agda"><a id="10209" href="NbE.html#9976" class="Function">↓ℕ̂</a> <a id="10213" class="Symbol">(</a><a id="10214" href="NbE.html#8629" class="InductiveConstructor">suc</a> <a id="10218" href="NbE.html#10218" class="Bound">n</a><a id="10219" class="Symbol">)</a> <a id="10221" class="Symbol">=</a> <a id="10223" href="NbE.html#10244" class="Function">suc↑</a> <a id="10228" class="Symbol">(</a><a id="10229" href="NbE.html#9976" class="Function">↓ℕ̂</a> <a id="10233" href="NbE.html#10218" class="Bound">n</a><a id="10234" class="Symbol">)</a> <a id="10236" class="Keyword">where</a>
  <a id="10244" href="NbE.html#10244" class="Function">suc↑</a> <a id="10249" class="Symbol">:</a> <a id="10251" href="NbE.html#7846" class="Function">Nf↑</a> <a id="10255" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="10259" class="Symbol">→</a> <a id="10261" href="NbE.html#7846" class="Function">Nf↑</a> <a id="10265" href="SystemT.html#580" class="InductiveConstructor">nat</a>
  <a id="10271" href="NbE.html#10244" class="Function">suc↑</a> <a id="10276" href="NbE.html#10276" class="Bound">𝓋̂</a> <a id="10279" href="NbE.html#10279" class="Bound">Γ</a> <a id="10281" class="Keyword">with</a> <a id="10286" href="NbE.html#10276" class="Bound">𝓋̂</a> <a id="10289" href="NbE.html#10279" class="Bound">Γ</a>
  <a id="10293" class="Symbol">...</a> <a id="10297" class="Symbol">|</a> <a id="10299" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="10301" href="NbE.html#10301" class="Bound">𝓋</a> <a id="10303" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="10305" href="NbE.html#10305" class="Bound">pf</a> <a id="10308" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="10310" class="Symbol">=</a> <a id="10312" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="10314" href="SystemT.html#3396" class="InductiveConstructor">suc</a> <a id="10318" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="10320" href="NbE.html#10301" class="Bound">𝓋</a> <a id="10322" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="10324" href="NbE.html#5672" class="InductiveConstructor">nf-suc</a> <a id="10331" href="NbE.html#10305" class="Bound">pf</a> <a id="10334" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
</pre>
In the case of an embedded liftable neutral, we use <code>zero</code> as
a fallback if the liftable neutral is undefined at the context. Our
proof of soundness later will be proof that this fallback is not
necessary in our algorithm.
<pre class="Agda"><a id="10572" href="NbE.html#9976" class="Function">↓ℕ̂</a> <a id="10576" class="Symbol">(</a><a id="10577" href="NbE.html#8645" class="InductiveConstructor">ne</a> <a id="10580" href="NbE.html#10580" class="Bound">𝓊̂</a><a id="10582" class="Symbol">)</a> <a id="10584" href="NbE.html#10584" class="Bound">Γ</a> <a id="10586" class="Keyword">with</a> <a id="10591" href="NbE.html#10580" class="Bound">𝓊̂</a> <a id="10594" href="NbE.html#10584" class="Bound">Γ</a>
<a id="10596" class="Symbol">...</a> <a id="10600" class="Symbol">|</a> <a id="10602" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="10607" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="10609" href="NbE.html#10609" class="Bound">𝓊</a> <a id="10611" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="10613" href="NbE.html#10613" class="Bound">pf</a> <a id="10616" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="10618" class="Symbol">=</a> <a id="10620" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="10622" href="NbE.html#10609" class="Bound">𝓊</a> <a id="10624" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="10626" href="NbE.html#5927" class="InductiveConstructor">nf-neutral</a> <a id="10637" href="NbE.html#10613" class="Bound">pf</a> <a id="10640" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
<a id="10642" class="Symbol">...</a> <a id="10646" class="Symbol">|</a> <a id="10648" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="10653" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>         <a id="10664" class="Symbol">=</a> <a id="10666" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="10668" href="SystemT.html#3378" class="InductiveConstructor">zero</a> <a id="10673" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="10675" href="NbE.html#5633" class="InductiveConstructor">nf-zero</a> <a id="10683" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
</pre>
For reification at function type, we will need the following function
which creates a “fresh” variable for a context Γ. Really, this is just
the de Brujin index 0 for a context <code>Γ , x:S</code>. This will be a
liftable variable that can be used in a context that is an extension of
<code>Γ , x:S</code> (and is undefined otherwise).
<pre class="Agda"><a id="𝓍̂"></a><a id="11009" href="NbE.html#11009" class="Function">𝓍̂</a> <a id="11012" class="Symbol">:</a> <a id="11014" class="Symbol">(</a><a id="11015" href="NbE.html#11015" class="Bound">S</a> <a id="11017" class="Symbol">:</a> <a id="11019" href="SystemT.html#561" class="Datatype">Type</a><a id="11023" class="Symbol">)</a> <a id="11025" class="Symbol">→</a> <a id="11027" href="SystemT.html#1272" class="Datatype">Γ</a> <a id="11029" class="Symbol">→</a> <a id="11031" href="NbE.html#7764" class="Function">Ne↑</a> <a id="11035" href="NbE.html#11015" class="Bound">S</a>
<a id="11037" href="NbE.html#11009" class="Function">𝓍̂</a> <a id="11040" href="NbE.html#11040" class="Bound">S</a> <a id="11042" href="NbE.html#11042" class="Bound">Γ</a> <a id="11044" href="NbE.html#11044" class="Bound">Γ′</a> <a id="11047" class="Keyword">with</a> <a id="11052" href="NbE.html#11044" class="Bound">Γ′</a> <a id="11055" href="SystemT.html#2177" class="Function Operator">≤?</a> <a id="11058" class="Symbol">(</a><a id="11059" href="NbE.html#11042" class="Bound">Γ</a> <a id="11061" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="11063" href="NbE.html#11040" class="Bound">S</a><a id="11064" class="Symbol">)</a>
<a id="11066" class="Symbol">...</a> <a id="11070" class="Symbol">|</a> <a id="11072" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="11075" class="Symbol">_</a> <a id="11077" class="Symbol">=</a> <a id="11079" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="11084" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="11087" class="Symbol">...</a> <a id="11091" class="Symbol">|</a> <a id="11093" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="11097" href="NbE.html#11097" class="Bound">pf</a> <a id="11100" class="Keyword">with</a> <a id="11105" href="SystemT.html#8593" class="Function">≤ᵨ</a> <a id="11108" href="NbE.html#11097" class="Bound">pf</a>
  <a id="11113" class="Comment">-- The variable x in the extended context Γ′ can</a>
  <a id="11164" class="Comment">-- be accessed through the renaming between Γ′ and</a>
  <a id="11217" class="Comment">-- Γ , S</a>
<a id="11226" class="Symbol">...</a> <a id="11230" class="Symbol">|</a> <a id="11232" class="Symbol">_</a> <a id="11234" href="SystemT.html#6380" class="InductiveConstructor Operator">,</a> <a id="11236" href="NbE.html#11236" class="Bound">x</a> <a id="11238" class="Symbol">=</a> <a id="11240" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="11245" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="11247" href="SystemT.html#3528" class="InductiveConstructor Operator">`</a> <a id="11249" href="NbE.html#11236" class="Bound">x</a> <a id="11251" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="11253" href="NbE.html#4971" class="InductiveConstructor">ne-var</a> <a id="11260" href="NbE.html#11236" class="Bound">x</a> <a id="11262" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
</pre>
For our reification function, we reuse ↓ℕ̂ at type nat.
<pre class="Agda"><a id="11333" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="11336" class="Symbol">{</a><a id="11337" href="SystemT.html#580" class="InductiveConstructor">nat</a><a id="11340" class="Symbol">}</a> <a id="11342" class="Symbol">=</a> <a id="11344" href="NbE.html#9976" class="Function">↓ℕ̂</a>
</pre>
For the eification of semantic objects of type ⟦S → T⟧ (which are
functions of type ⟦S⟧ → ⟦T⟧), the resulting normal term is an
abstraction over the reification of the function applied to the
reflection of the bound variable, for which we use 𝓍̂
<pre class="Agda"><a id="11608" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="11611" class="Symbol">{</a><a id="11612" href="NbE.html#11612" class="Bound">S</a> <a id="11614" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="11616" href="NbE.html#11616" class="Bound">T</a><a id="11617" class="Symbol">}</a> <a id="11619" href="NbE.html#11619" class="Bound">f</a> <a id="11621" href="NbE.html#11621" class="Bound">Γ</a> <a id="11623" class="Keyword">with</a> <a id="11628" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="11631" class="Symbol">(</a><a id="11632" href="NbE.html#11619" class="Bound">f</a> <a id="11634" href="NbE.html#11651" class="Function">a</a><a id="11635" class="Symbol">)</a> <a id="11637" class="Symbol">(</a><a id="11638" href="NbE.html#11621" class="Bound">Γ</a> <a id="11640" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="11642" href="NbE.html#11612" class="Bound">S</a><a id="11643" class="Symbol">)</a> <a id="11645" class="Keyword">where</a> <a id="11651" href="NbE.html#11651" class="Function">a</a> <a id="11653" class="Symbol">=</a> <a id="11655" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="11658" class="Symbol">(</a><a id="11659" href="NbE.html#11009" class="Function">𝓍̂</a> <a id="11662" href="NbE.html#11612" class="Bound">S</a> <a id="11664" href="NbE.html#11621" class="Bound">Γ</a><a id="11665" class="Symbol">)</a>
<a id="11667" class="Symbol">...</a> <a id="11671" class="Symbol">|</a> <a id="11673" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="11675" href="NbE.html#11675" class="Bound">𝓋</a> <a id="11677" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="11679" href="NbE.html#11679" class="Bound">pf</a> <a id="11682" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="11684" class="Symbol">=</a> <a id="11686" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="11688" href="SystemT.html#3588" class="InductiveConstructor Operator">ƛ</a> <a id="11690" href="NbE.html#11675" class="Bound">𝓋</a> <a id="11692" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="11694" href="NbE.html#5790" class="InductiveConstructor">nf-abs</a> <a id="11701" href="NbE.html#11679" class="Bound">pf</a> <a id="11704" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
</pre>
With these two functions in place, we can define the reflection of a
context Γ into an environment. This will be the reflected environment
over which a typed term in the context Γ will be evaluated.
<pre class="Agda"><a id="↑Γ"></a><a id="11918" href="NbE.html#11918" class="Function">↑Γ</a> <a id="11921" class="Symbol">:</a> <a id="11923" class="Symbol">∀</a> <a id="11925" class="Symbol">(</a><a id="11926" href="NbE.html#11926" class="Bound">Γ</a> <a id="11928" class="Symbol">:</a> <a id="11930" href="SystemT.html#1272" class="Datatype">Γ</a><a id="11931" class="Symbol">)</a> <a id="11933" class="Symbol">→</a> <a id="11935" href="NbE.html#849" class="Field Operator">⟦</a> <a id="11937" href="NbE.html#11926" class="Bound">Γ</a> <a id="11939" href="NbE.html#849" class="Field Operator">⟧</a>
<a id="11941" href="NbE.html#11918" class="Function">↑Γ</a> <a id="11944" href="SystemT.html#1288" class="InductiveConstructor">∅</a> <a id="11946" class="Symbol">=</a> <a id="11948" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="11951" href="NbE.html#11918" class="Function">↑Γ</a> <a id="11954" class="Symbol">(</a><a id="11955" href="NbE.html#11955" class="Bound">Γ</a> <a id="11957" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="11959" href="NbE.html#11959" class="Bound">T</a><a id="11960" class="Symbol">)</a> <a id="11962" class="Symbol">=</a> <a id="11964" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="11966" href="NbE.html#11918" class="Function">↑Γ</a> <a id="11969" href="NbE.html#11955" class="Bound">Γ</a>  <a id="11972" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="11974" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="11977" class="Symbol">(</a><a id="11978" href="NbE.html#11009" class="Function">𝓍̂</a> <a id="11981" href="NbE.html#11959" class="Bound">T</a> <a id="11983" href="NbE.html#11955" class="Bound">Γ</a><a id="11984" class="Symbol">)</a> <a id="11986" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
</pre>
We also need to use reflection and reification to define the
interpretation of primitive recursion in System T, which must work with
liftable neutrals (as our interpretation of nat now has them embedded)
<pre class="Agda"><a id="rec↑"></a><a id="12205" href="NbE.html#12205" class="Function">rec↑</a> <a id="12210" class="Symbol">:</a> <a id="12212" class="Symbol">∀</a> <a id="12214" class="Symbol">{</a><a id="12215" href="NbE.html#12215" class="Bound">T</a> <a id="12217" class="Symbol">:</a> <a id="12219" href="SystemT.html#561" class="Datatype">Type</a><a id="12223" class="Symbol">}</a> <a id="12225" class="Symbol">→</a> <a id="12227" href="NbE.html#7846" class="Function">Nf↑</a> <a id="12231" href="NbE.html#12215" class="Bound">T</a> <a id="12233" class="Symbol">→</a> <a id="12235" href="NbE.html#7846" class="Function">Nf↑</a> <a id="12239" class="Symbol">(</a><a id="12240" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="12244" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12246" href="NbE.html#12215" class="Bound">T</a> <a id="12248" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12250" href="NbE.html#12215" class="Bound">T</a><a id="12251" class="Symbol">)</a> <a id="12253" class="Symbol">→</a> <a id="12255" href="NbE.html#7764" class="Function">Ne↑</a> <a id="12259" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="12263" class="Symbol">→</a> <a id="12265" href="NbE.html#7764" class="Function">Ne↑</a> <a id="12269" href="NbE.html#12215" class="Bound">T</a>
<a id="12271" href="NbE.html#12205" class="Function">rec↑</a> <a id="12276" href="NbE.html#12276" class="Bound">𝓋̂z</a> <a id="12280" href="NbE.html#12280" class="Bound">𝓋̂s</a> <a id="12284" href="NbE.html#12284" class="Bound">𝓊̂</a> <a id="12287" href="NbE.html#12287" class="Bound">Γ</a> <a id="12289" class="Keyword">with</a> <a id="12294" href="NbE.html#12284" class="Bound">𝓊̂</a> <a id="12297" href="NbE.html#12287" class="Bound">Γ</a>
<a id="12299" class="Symbol">...</a> <a id="12303" class="Symbol">|</a> <a id="12305" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="12310" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a> <a id="12313" class="Symbol">=</a> <a id="12315" href="Data.Sum.Base.html#809" class="InductiveConstructor">inj₂</a> <a id="12320" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
<a id="12323" class="Symbol">...</a> <a id="12327" class="Symbol">|</a> <a id="12329" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="12334" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="12336" href="NbE.html#12336" class="Bound">𝓊</a> <a id="12338" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="12340" href="NbE.html#12340" class="Bound">pf-𝓊</a> <a id="12345" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
      <a id="12353" class="Keyword">with</a> <a id="12358" class="Bound">𝓋̂z</a> <a id="12362" class="Bound">Γ</a>      <a id="12369" class="Symbol">|</a> <a id="12371" class="Bound">𝓋̂s</a> <a id="12375" class="Bound">Γ</a>
<a id="12377" class="Symbol">...</a> <a id="12381" class="Symbol">|</a> <a id="12383" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="12385" href="NbE.html#12385" class="Bound">𝓋z</a> <a id="12388" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="12390" href="NbE.html#12390" class="Bound">pf-𝓋z</a> <a id="12396" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="12398" class="Symbol">|</a> <a id="12400" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="12402" href="NbE.html#12402" class="Bound">𝓋s</a> <a id="12405" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="12407" href="NbE.html#12407" class="Bound">pf-𝓋s</a> <a id="12413" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="12415" class="Symbol">=</a>
  <a id="12419" href="Data.Sum.Base.html#784" class="InductiveConstructor">inj₁</a> <a id="12424" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="12426" href="SystemT.html#3419" class="InductiveConstructor">rec</a> <a id="12430" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="12432" href="NbE.html#12385" class="Bound">𝓋z</a> <a id="12435" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="12437" href="NbE.html#12402" class="Bound">𝓋s</a> <a id="12440" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="12442" class="Bound">𝓊</a> <a id="12444" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="12446" href="NbE.html#5194" class="InductiveConstructor">ne-rec</a> <a id="12453" href="NbE.html#12390" class="Bound">pf-𝓋z</a> <a id="12459" href="NbE.html#12407" class="Bound">pf-𝓋s</a> <a id="12465" class="Bound">pf-𝓊</a> <a id="12470" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>

<a id="⟦rec⟧"></a><a id="12473" href="NbE.html#12473" class="Function">⟦rec⟧</a> <a id="12479" class="Symbol">:</a> <a id="12481" class="Symbol">∀</a> <a id="12483" class="Symbol">{</a><a id="12484" href="NbE.html#12484" class="Bound">T</a> <a id="12486" class="Symbol">:</a> <a id="12488" href="SystemT.html#561" class="Datatype">Type</a><a id="12492" class="Symbol">}</a> <a id="12494" class="Symbol">→</a> <a id="12496" href="NbE.html#849" class="Field Operator">⟦</a> <a id="12498" href="NbE.html#12484" class="Bound">T</a> <a id="12500" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12502" class="Symbol">(</a><a id="12503" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="12507" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12509" href="NbE.html#12484" class="Bound">T</a> <a id="12511" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12513" href="NbE.html#12484" class="Bound">T</a><a id="12514" class="Symbol">)</a> <a id="12516" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12518" href="SystemT.html#580" class="InductiveConstructor">nat</a> <a id="12522" href="SystemT.html#593" class="InductiveConstructor Operator">⇒</a> <a id="12524" href="NbE.html#12484" class="Bound">T</a> <a id="12526" href="NbE.html#849" class="Field Operator">⟧</a>
<a id="12528" href="NbE.html#12473" class="Function">⟦rec⟧</a> <a id="12534" href="NbE.html#12534" class="Bound">z</a> <a id="12536" href="NbE.html#12536" class="Bound">s</a> <a id="12538" href="NbE.html#8617" class="InductiveConstructor">zero</a> <a id="12543" class="Symbol">=</a> <a id="12545" href="NbE.html#12534" class="Bound">z</a>
<a id="12547" href="NbE.html#12473" class="Function">⟦rec⟧</a> <a id="12553" href="NbE.html#12553" class="Bound">z</a> <a id="12555" href="NbE.html#12555" class="Bound">s</a> <a id="12557" class="Symbol">(</a><a id="12558" href="NbE.html#8629" class="InductiveConstructor">suc</a> <a id="12562" href="NbE.html#12562" class="Bound">n</a><a id="12563" class="Symbol">)</a> <a id="12565" class="Symbol">=</a> <a id="12567" href="NbE.html#12555" class="Bound">s</a> <a id="12569" href="NbE.html#12562" class="Bound">n</a> <a id="12571" class="Symbol">(</a><a id="12572" href="NbE.html#12473" class="Function">⟦rec⟧</a> <a id="12578" href="NbE.html#12553" class="Bound">z</a> <a id="12580" href="NbE.html#12555" class="Bound">s</a> <a id="12582" href="NbE.html#12562" class="Bound">n</a><a id="12583" class="Symbol">)</a>
<a id="12585" href="NbE.html#12473" class="Function">⟦rec⟧</a> <a id="12591" class="Symbol">{</a><a id="12592" href="NbE.html#12592" class="Bound">T</a><a id="12593" class="Symbol">}</a> <a id="12595" href="NbE.html#12595" class="Bound">z</a> <a id="12597" href="NbE.html#12597" class="Bound">s</a> <a id="12599" class="Symbol">(</a><a id="12600" href="NbE.html#8645" class="InductiveConstructor">ne</a> <a id="12603" href="NbE.html#12603" class="Bound">𝓊̂</a><a id="12605" class="Symbol">)</a> <a id="12607" class="Symbol">=</a>
  <a id="12611" href="NbE.html#9074" class="Function">↑ᵀ</a> <a id="12614" class="Symbol">(</a><a id="12615" href="NbE.html#12205" class="Function">rec↑</a> <a id="12620" href="NbE.html#12638" class="Function">𝓋̂z</a> <a id="12624" href="NbE.html#12651" class="Function">𝓋̂s</a> <a id="12628" href="NbE.html#12603" class="Bound">𝓊̂</a><a id="12630" class="Symbol">)</a> <a id="12632" class="Keyword">where</a> <a id="12638" href="NbE.html#12638" class="Function">𝓋̂z</a> <a id="12642" class="Symbol">=</a> <a id="12644" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="12647" href="NbE.html#12595" class="Bound">z</a> <a id="12649" class="Symbol">;</a> <a id="12651" href="NbE.html#12651" class="Function">𝓋̂s</a> <a id="12655" class="Symbol">=</a> <a id="12657" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="12660" href="NbE.html#12597" class="Bound">s</a>
</pre>
Now that we have a concrete interpretation of types, and an
interpretation for primitive recursion, we can define the corresponding
interpretations of the lookup and typing judgements.
<pre class="Agda"><a id="⟦_∋Γ⟧"></a><a id="12860" href="NbE.html#12860" class="Function Operator">⟦_∋Γ⟧</a> <a id="12866" class="Symbol">:</a> <a id="12868" class="Symbol">∀</a> <a id="12870" class="Symbol">{</a><a id="12871" href="NbE.html#12871" class="Bound">Γ</a> <a id="12873" class="Symbol">:</a> <a id="12875" href="SystemT.html#1272" class="Datatype">Γ</a><a id="12876" class="Symbol">}</a> <a id="12878" class="Symbol">{</a><a id="12879" href="NbE.html#12879" class="Bound">T</a> <a id="12881" class="Symbol">:</a> <a id="12883" href="SystemT.html#561" class="Datatype">Type</a><a id="12887" class="Symbol">}</a> <a id="12889" class="Symbol">→</a> <a id="12891" href="NbE.html#12871" class="Bound">Γ</a> <a id="12893" href="SystemT.html#2683" class="Datatype Operator">∋</a> <a id="12895" href="NbE.html#12879" class="Bound">T</a> <a id="12897" class="Symbol">→</a> <a id="12899" href="NbE.html#849" class="Field Operator">⟦</a> <a id="12901" href="NbE.html#12871" class="Bound">Γ</a> <a id="12903" href="NbE.html#849" class="Field Operator">⟧</a> <a id="12905" class="Symbol">→</a> <a id="12907" href="NbE.html#849" class="Field Operator">⟦</a> <a id="12909" href="NbE.html#12879" class="Bound">T</a> <a id="12911" href="NbE.html#849" class="Field Operator">⟧</a>
<a id="12913" href="NbE.html#12860" class="Function Operator">⟦_∋Γ⟧</a> <a id="12919" class="Symbol">{</a><a id="12920" href="NbE.html#12920" class="Bound">Γ</a> <a id="12922" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="12924" href="NbE.html#12924" class="Bound">T</a><a id="12925" class="Symbol">}</a> <a id="12927" href="SystemT.html#2712" class="InductiveConstructor">`Z</a> <a id="12930" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="12932" class="Symbol">_</a> <a id="12934" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="12936" href="NbE.html#12936" class="Bound">a</a> <a id="12938" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="12940" class="Symbol">=</a> <a id="12942" href="NbE.html#12936" class="Bound">a</a>
<a id="12944" href="NbE.html#12860" class="Function Operator">⟦_∋Γ⟧</a> <a id="12950" class="Symbol">{</a><a id="12951" href="NbE.html#12951" class="Bound">Γ</a> <a id="12953" href="SystemT.html#1296" class="InductiveConstructor Operator">,</a> <a id="12955" href="NbE.html#12955" class="Bound">T</a><a id="12956" class="Symbol">}</a> <a id="12958" class="Symbol">(</a><a id="12959" href="SystemT.html#2777" class="InductiveConstructor Operator">`S</a> <a id="12962" href="NbE.html#12962" class="Bound">x</a><a id="12963" class="Symbol">)</a> <a id="12965" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="12967" href="NbE.html#12967" class="Bound">ρ</a> <a id="12969" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="12971" class="Symbol">_</a> <a id="12973" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="12975" class="Symbol">=</a> <a id="12977" href="NbE.html#12860" class="Function Operator">⟦</a> <a id="12979" href="NbE.html#12962" class="Bound">x</a> <a id="12981" href="NbE.html#12860" class="Function Operator">∋Γ⟧</a> <a id="12985" href="NbE.html#12967" class="Bound">ρ</a>

<a id="⟦⊢_⟧"></a><a id="12988" href="NbE.html#12988" class="Function Operator">⟦⊢_⟧</a> <a id="12993" class="Symbol">:</a> <a id="12995" class="Symbol">∀</a> <a id="12997" class="Symbol">{</a><a id="12998" href="NbE.html#12998" class="Bound">Γ</a> <a id="13000" class="Symbol">:</a> <a id="13002" href="SystemT.html#1272" class="Datatype">Γ</a><a id="13003" class="Symbol">}</a> <a id="13005" class="Symbol">{</a><a id="13006" href="NbE.html#13006" class="Bound">T</a> <a id="13008" class="Symbol">:</a> <a id="13010" href="SystemT.html#561" class="Datatype">Type</a><a id="13014" class="Symbol">}</a> <a id="13016" class="Symbol">→</a> <a id="13018" href="NbE.html#12998" class="Bound">Γ</a> <a id="13020" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="13022" href="NbE.html#13006" class="Bound">T</a> <a id="13024" class="Symbol">→</a> <a id="13026" href="NbE.html#849" class="Field Operator">⟦</a> <a id="13028" href="NbE.html#12998" class="Bound">Γ</a> <a id="13030" href="NbE.html#849" class="Field Operator">⟧</a> <a id="13032" class="Symbol">→</a> <a id="13034" href="NbE.html#849" class="Field Operator">⟦</a> <a id="13036" href="NbE.html#13006" class="Bound">T</a> <a id="13038" href="NbE.html#849" class="Field Operator">⟧</a>
<a id="13040" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13043" href="SystemT.html#3378" class="InductiveConstructor">zero</a> <a id="13048" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13050" class="Symbol">_</a> <a id="13052" class="Symbol">=</a> <a id="13054" href="NbE.html#8617" class="InductiveConstructor">zero</a>
<a id="13059" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13062" href="SystemT.html#3396" class="InductiveConstructor">suc</a> <a id="13066" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13068" class="Symbol">_</a> <a id="13070" class="Symbol">=</a> <a id="13072" href="NbE.html#8629" class="InductiveConstructor">suc</a>
<a id="13076" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13079" href="SystemT.html#3419" class="InductiveConstructor">rec</a> <a id="13083" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13085" class="Symbol">_</a> <a id="13087" class="Symbol">=</a> <a id="13089" href="NbE.html#12473" class="Function">⟦rec⟧</a>
<a id="13095" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13098" href="SystemT.html#3528" class="InductiveConstructor Operator">`</a> <a id="13100" href="NbE.html#13100" class="Bound">x</a> <a id="13102" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13104" class="Symbol">=</a> <a id="13106" href="NbE.html#12860" class="Function Operator">⟦</a> <a id="13108" href="NbE.html#13100" class="Bound">x</a> <a id="13110" href="NbE.html#12860" class="Function Operator">∋Γ⟧</a>
<a id="13114" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13117" href="SystemT.html#3588" class="InductiveConstructor Operator">ƛ</a> <a id="13119" href="NbE.html#13119" class="Bound">t</a> <a id="13121" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13123" href="NbE.html#13123" class="Bound">ρ</a> <a id="13125" href="NbE.html#13125" class="Bound">a</a> <a id="13127" class="Symbol">=</a> <a id="13129" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13132" href="NbE.html#13119" class="Bound">t</a> <a id="13134" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13136" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="13138" href="NbE.html#13123" class="Bound">ρ</a> <a id="13140" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="13142" href="NbE.html#13125" class="Bound">a</a> <a id="13144" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a>
<a id="13146" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13149" href="NbE.html#13149" class="Bound">r</a> <a id="13151" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="13153" href="NbE.html#13153" class="Bound">s</a> <a id="13155" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13157" href="NbE.html#13157" class="Bound">ρ</a> <a id="13159" class="Symbol">=</a> <a id="13161" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13164" href="NbE.html#13149" class="Bound">r</a> <a id="13166" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13168" href="NbE.html#13157" class="Bound">ρ</a> <a id="13170" class="Symbol">(</a><a id="13171" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13174" href="NbE.html#13153" class="Bound">s</a> <a id="13176" href="NbE.html#12988" class="Function Operator">⟧</a>  <a id="13179" href="NbE.html#13157" class="Bound">ρ</a><a id="13180" class="Symbol">)</a>
</pre>
Finally, the algorithm for normalization by evaluation is as follows
<pre class="Agda"><a id="nbe"></a><a id="13264" href="NbE.html#13264" class="Function">nbe</a> <a id="13268" class="Symbol">:</a> <a id="13270" class="Symbol">∀</a> <a id="13272" class="Symbol">{</a><a id="13273" href="NbE.html#13273" class="Bound">Γ</a> <a id="13275" class="Symbol">:</a> <a id="13277" href="SystemT.html#1272" class="Datatype">Γ</a><a id="13278" class="Symbol">}</a> <a id="13280" class="Symbol">{</a><a id="13281" href="NbE.html#13281" class="Bound">T</a> <a id="13283" class="Symbol">:</a> <a id="13285" href="SystemT.html#561" class="Datatype">Type</a><a id="13289" class="Symbol">}</a> <a id="13291" class="Symbol">→</a> <a id="13293" href="NbE.html#13273" class="Bound">Γ</a> <a id="13295" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="13297" href="NbE.html#13281" class="Bound">T</a> <a id="13299" class="Symbol">→</a> <a id="13301" href="Data.Product.html#1806" class="Function">∃[</a> <a id="13304" href="NbE.html#13304" class="Bound">t</a> <a id="13306" href="Data.Product.html#1806" class="Function">]</a> <a id="13308" href="NbE.html#4672" class="Datatype">Nf</a> <a id="13311" href="NbE.html#13281" class="Bound">T</a> <a id="13313" href="NbE.html#13273" class="Bound">Γ</a> <a id="13315" href="NbE.html#13304" class="Bound">t</a>
<a id="13317" href="NbE.html#13264" class="Function">nbe</a> <a id="13321" class="Symbol">{</a><a id="13322" href="NbE.html#13322" class="Bound">Γ</a><a id="13323" class="Symbol">}</a> <a id="13325" href="NbE.html#13325" class="Bound">t</a> <a id="13327" class="Symbol">=</a> <a id="13329" href="NbE.html#9180" class="Function">↓ᵀ</a> <a id="13332" class="Symbol">(</a><a id="13333" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="13336" href="NbE.html#13325" class="Bound">t</a> <a id="13338" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="13340" class="Symbol">(</a><a id="13341" href="NbE.html#11918" class="Function">↑Γ</a> <a id="13344" href="NbE.html#13322" class="Bound">Γ</a><a id="13345" class="Symbol">))</a> <a id="13348" href="NbE.html#13322" class="Bound">Γ</a>

<a id="nf"></a><a id="13351" href="NbE.html#13351" class="Function">nf</a> <a id="13354" class="Symbol">:</a> <a id="13356" class="Symbol">∀</a> <a id="13358" class="Symbol">{</a><a id="13359" href="NbE.html#13359" class="Bound">Γ</a> <a id="13361" class="Symbol">:</a> <a id="13363" href="SystemT.html#1272" class="Datatype">Γ</a><a id="13364" class="Symbol">}</a> <a id="13366" class="Symbol">{</a><a id="13367" href="NbE.html#13367" class="Bound">T</a> <a id="13369" class="Symbol">:</a> <a id="13371" href="SystemT.html#561" class="Datatype">Type</a><a id="13375" class="Symbol">}</a> <a id="13377" class="Symbol">→</a> <a id="13379" href="NbE.html#13359" class="Bound">Γ</a> <a id="13381" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="13383" href="NbE.html#13367" class="Bound">T</a> <a id="13385" class="Symbol">→</a> <a id="13387" href="NbE.html#13359" class="Bound">Γ</a> <a id="13389" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="13391" href="NbE.html#13367" class="Bound">T</a>
<a id="13393" href="NbE.html#13351" class="Function">nf</a> <a id="13396" href="NbE.html#13396" class="Bound">t</a> <a id="13398" class="Keyword">with</a> <a id="13403" href="NbE.html#13264" class="Function">nbe</a> <a id="13407" href="NbE.html#13396" class="Bound">t</a>
<a id="13409" class="Symbol">...</a> <a id="13413" class="Symbol">|</a> <a id="13415" href="NbE.html#279" class="InductiveConstructor Operator">⟨</a> <a id="13417" href="NbE.html#13417" class="Bound">t′</a> <a id="13420" href="NbE.html#279" class="InductiveConstructor Operator">,</a> <a id="13422" class="Symbol">_</a> <a id="13424" href="NbE.html#279" class="InductiveConstructor Operator">⟩</a> <a id="13426" class="Symbol">=</a> <a id="13428" href="NbE.html#13417" class="Bound">t′</a>
</pre>
<p>And here we have some examples of the algorithm in action, reusing
our examples from <a href="./SystemT.lagda.md">SystemT</a></p>
<pre class="Agda"><a id="13560" class="Comment">-- normal form of (λx. x) zero is zero</a>
<a id="nf-ex1"></a><a id="13599" href="NbE.html#13599" class="Function">nf-ex1</a> <a id="13606" class="Symbol">:</a> <a id="13608" href="NbE.html#13351" class="Function">nf</a> <a id="13611" href="SystemT.html#3965" class="Function">ex1</a> <a id="13615" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13617" class="InductiveConstructor">zero</a>
<a id="13622" href="NbE.html#13599" class="Function">nf-ex1</a> <a id="13629" class="Keyword">with</a> <a id="13634" href="SystemT.html#3965" class="Function">ex1</a>
<a id="13638" href="NbE.html#13599" class="Function">...</a> <a id="13642" class="Symbol">|</a> <a id="13644" class="Symbol">_</a> <a id="13646" class="Symbol">=</a> <a id="13648" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="13654" class="Comment">-- normal form of suc ((λx. x) zero) is suc zero</a>
<a id="nf-ex2"></a><a id="13703" href="NbE.html#13703" class="Function">nf-ex2</a> <a id="13710" class="Symbol">:</a> <a id="13712" href="NbE.html#13351" class="Function">nf</a> <a id="13715" href="SystemT.html#4009" class="Function">ex2</a> <a id="13719" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13721" class="Symbol">(</a><a id="13722" class="InductiveConstructor">suc</a> <a id="13726" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="13728" class="InductiveConstructor">zero</a><a id="13732" class="Symbol">)</a>
<a id="13734" href="NbE.html#13703" class="Function">nf-ex2</a> <a id="13741" class="Keyword">with</a> <a id="13746" href="SystemT.html#4009" class="Function">ex2</a>
<a id="13750" href="NbE.html#13703" class="Function">...</a> <a id="13754" class="Symbol">|</a> <a id="13756" class="Symbol">_</a> <a id="13758" class="Symbol">=</a> <a id="13760" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="13766" class="Comment">-- normal form of x:nat, y:nat ⊢ suc ((λz. suc y) x)</a>
<a id="13819" class="Comment">-- is x:nat, y:nat ⊢ suc (suc y)</a>
<a id="nf-ex3"></a><a id="13852" href="NbE.html#13852" class="Function">nf-ex3</a> <a id="13859" class="Symbol">:</a> <a id="13861" href="NbE.html#13351" class="Function">nf</a> <a id="13864" href="SystemT.html#4064" class="Function">ex3</a> <a id="13868" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="13870" class="Symbol">(</a><a id="13871" class="InductiveConstructor">suc</a> <a id="13875" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="13877" class="Symbol">(</a><a id="13878" class="InductiveConstructor">suc</a> <a id="13882" href="SystemT.html#3662" class="InductiveConstructor Operator">·</a> <a id="13884" href="SystemT.html#3528" class="InductiveConstructor Operator">`</a> <a id="13886" class="Symbol">(</a><a id="13887" href="SystemT.html#2712" class="InductiveConstructor">`Z</a><a id="13889" class="Symbol">)))</a>
<a id="13893" href="NbE.html#13852" class="Function">nf-ex3</a> <a id="13900" class="Keyword">with</a> <a id="13905" href="SystemT.html#4064" class="Function">ex3</a>
<a id="13909" href="NbE.html#13852" class="Function">...</a> <a id="13913" class="Symbol">|</a> <a id="13915" class="Symbol">_</a> <a id="13917" class="Symbol">=</a> <a id="13919" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
<p>As for the soundness properties we want from this algorithm: -
<code>Γ ⊢ nf(t) : T</code> (well-typedness) We are using an
intrinsically typed representation of terms, so this property is given
to us automatically</p>
<ul>
<li><p><code>⟦ nf(t) ⟧ = ⟦ t ⟧</code> (preservation of meaning) We will
prove this in the following section using definitional equality <a href="./Soundness.lagda.md">Soundness</a></p></li>
<li><p><code>nf(nf(t)) = nf(t)</code> (idempotency) This follows
directly from the preservation of meaning and completeness properties of
the algorithm:</p>
<p>By the soundness property of preservation of meaning, we have
<code>Γ ⊢ nf t = t : T</code>, which implies
<code>nf (nf t) = nf(t)</code> by completeness</p></li>
</ul>
<p>For proving the completeness property of NbE, our goal is to prove
that two programs with the same meaning (i.e. definitionally equal) have
the same normal form:</p>
<pre><code>Γ ⊢ t = t′ : T implies nf(t) = nf(t′)</code></pre>
<p>We can prove this using some equational reasoning paired with the
definitional equality of two terms impliying they are semantically equal
(included as a postulate for now)</p>
<pre class="Agda"><a id="15013" class="Keyword">postulate</a>
  <a id="==→⟦≡⟧"></a><a id="15025" href="NbE.html#15025" class="Postulate">==→⟦≡⟧</a> <a id="15032" class="Symbol">:</a> <a id="15034" class="Symbol">∀</a> <a id="15036" class="Symbol">{</a><a id="15037" href="NbE.html#15037" class="Bound">Γ</a> <a id="15039" class="Symbol">:</a> <a id="15041" href="SystemT.html#1272" class="Datatype">Γ</a><a id="15042" class="Symbol">}</a> <a id="15044" class="Symbol">{</a><a id="15045" href="NbE.html#15045" class="Bound">T</a> <a id="15047" class="Symbol">:</a> <a id="15049" href="SystemT.html#561" class="Datatype">Type</a><a id="15053" class="Symbol">}</a> <a id="15055" class="Symbol">{</a><a id="15056" href="NbE.html#15056" class="Bound">t</a> <a id="15058" href="NbE.html#15058" class="Bound">t′</a> <a id="15061" class="Symbol">:</a> <a id="15063" href="NbE.html#15037" class="Bound">Γ</a> <a id="15065" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="15067" href="NbE.html#15045" class="Bound">T</a><a id="15068" class="Symbol">}</a> <a id="15070" class="Symbol">{</a><a id="15071" href="NbE.html#15071" class="Bound">ρ</a> <a id="15073" class="Symbol">:</a> <a id="15075" href="NbE.html#849" class="Field Operator">⟦</a> <a id="15077" href="NbE.html#15037" class="Bound">Γ</a> <a id="15079" href="NbE.html#849" class="Field Operator">⟧</a><a id="15080" class="Symbol">}</a>
         <a id="15091" class="Symbol">→</a> <a id="15093" href="NbE.html#15056" class="Bound">t</a> <a id="15095" href="SystemT.html#11908" class="Datatype Operator">==</a> <a id="15098" href="NbE.html#15058" class="Bound">t′</a>
         <a id="15110" class="Symbol">→</a> <a id="15112" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="15115" href="NbE.html#15056" class="Bound">t</a> <a id="15117" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="15119" href="NbE.html#15071" class="Bound">ρ</a> <a id="15121" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15123" href="NbE.html#12988" class="Function Operator">⟦⊢</a> <a id="15126" href="NbE.html#15058" class="Bound">t′</a> <a id="15129" href="NbE.html#12988" class="Function Operator">⟧</a> <a id="15131" href="NbE.html#15071" class="Bound">ρ</a>

<a id="completeness"></a><a id="15134" href="NbE.html#15134" class="Function">completeness</a> <a id="15147" class="Symbol">:</a> <a id="15149" class="Symbol">∀</a> <a id="15151" class="Symbol">{</a><a id="15152" href="NbE.html#15152" class="Bound">Γ</a> <a id="15154" class="Symbol">:</a> <a id="15156" href="SystemT.html#1272" class="Datatype">Γ</a><a id="15157" class="Symbol">}</a> <a id="15159" class="Symbol">{</a><a id="15160" href="NbE.html#15160" class="Bound">T</a> <a id="15162" class="Symbol">:</a> <a id="15164" href="SystemT.html#561" class="Datatype">Type</a><a id="15168" class="Symbol">}</a> <a id="15170" class="Symbol">{</a><a id="15171" href="NbE.html#15171" class="Bound">t</a> <a id="15173" href="NbE.html#15173" class="Bound">t′</a> <a id="15176" class="Symbol">:</a> <a id="15178" href="NbE.html#15152" class="Bound">Γ</a> <a id="15180" href="SystemT.html#3345" class="Datatype Operator">⊢</a> <a id="15182" href="NbE.html#15160" class="Bound">T</a><a id="15183" class="Symbol">}</a>
             <a id="15198" class="Symbol">→</a> <a id="15200" href="NbE.html#15171" class="Bound">t</a> <a id="15202" href="SystemT.html#11908" class="Datatype Operator">==</a> <a id="15205" href="NbE.html#15173" class="Bound">t′</a>
             <a id="15221" class="Symbol">→</a> <a id="15223" href="NbE.html#13351" class="Function">nf</a> <a id="15226" href="NbE.html#15171" class="Bound">t</a> <a id="15228" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="15230" href="NbE.html#13351" class="Function">nf</a> <a id="15233" href="NbE.html#15173" class="Bound">t′</a>
<a id="15236" href="NbE.html#15134" class="Function">completeness</a> <a id="15249" class="Symbol">{</a><a id="15250" href="NbE.html#15250" class="Bound">Γ</a><a id="15251" class="Symbol">}</a> <a id="15253" href="NbE.html#15253" class="Bound">t==t′</a> <a id="15259" class="Keyword">rewrite</a> <a id="15267" href="NbE.html#15025" class="Postulate">==→⟦≡⟧</a> <a id="15274" class="Symbol">{</a><a id="15275" class="Argument">ρ</a> <a id="15277" class="Symbol">=</a> <a id="15279" href="NbE.html#11918" class="Function">↑Γ</a> <a id="15282" href="NbE.html#15250" class="Bound">Γ</a><a id="15283" class="Symbol">}</a> <a id="15285" href="NbE.html#15253" class="Bound">t==t′</a> <a id="15291" class="Symbol">=</a> <a id="15293" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
</pre>
</body>
</html>
